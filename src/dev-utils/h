#!/usr/bin/env python3

import argparse
import base64
import logging
import os
import json
import yaml
import mysql.connector
import multiprocessing
import subprocess

from kubernetes import client as k8s_client
from kubernetes.client import Configuration, ApiClient


logger = logging.getLogger(__name__)


def find_infra_node_name(machines):
    for hostname, val in machines.items():
        role_val = val.get("role")
        if type(role_val) == str and role_val == "infrastructure":
            return hostname
        elif type(role_val) == list:
            for role in role_val:
                if role == "infra":
                    return hostname


def get_config(config_path):
    config_path = os.path.join(config_path, "config.yaml")
    with open(config_path) as f:
        config = yaml.full_load(f)
    return config


def get_cluster_id(config_path):
    with open(os.path.join(config_path, "clusterID", "clusterID.yml")) as f:
        cluster_id = yaml.safe_load(f)["clusterId"]
    return cluster_id


def get_conn(config_path):
    config = get_config(config_path)
    cluster_id = get_cluster_id(config_path)
    conn = mysql.connector.connect(
        user=config["mysql_username"],
        password=config["mysql_password"],
        host=config["mysql_node"],
        database="DLWSCluster-%s" % cluster_id)
    return conn


def get_expected_capacity(config_path):
    conn = None
    cursor = None
    ret = None
    try:
        conn = get_conn(config_path)
        cursor = conn.cursor()
        query = "SELECT `resourceMetadata` FROM `vc` LIMIT 1"
        cursor.execute(query)
        for resource_metadata in cursor:
            data = json.loads(resource_metadata[0])
            for sku, meta in data["gpu"].items():
                ret = int(meta["per_node"])
        conn.commit()
    except Exception:
        logger.exception("Failed to get expected capacity")
    finally:
        if cursor is not None:
            cursor.close()
        if conn is not None:
            conn.close()
    return ret


def get_user(config_path):
    cluster_path = os.path.join(config_path, "cluster.yaml")
    if os.path.isfile(cluster_path):
        with open(cluster_path) as f:
            cluster_config = yaml.full_load(f)
        return cluster_config["admin_username"]

    status_path = os.path.join(config_path, "status.yaml")
    with open(status_path) as f:
        status_config = yaml.full_load(f)
        for machine, machine_info in status_config["machines"].items():
            if "infra" in machine_info["role"]:
                return machine_info["admin_username"]
    return None


def get_domain(config_path):
    cluster_path = os.path.join(config_path, "cluster.yaml")
    if os.path.isfile(cluster_path):
        with open(cluster_path) as f:
            cluster_config = yaml.full_load(f)
        return cluster_config["network"]["domain"]

    status_path = os.path.join(config_path, "status.yaml")
    with open(status_path) as f:
        status_config = yaml.full_load(f)
        for machine, machine_info in status_config["machines"].items():
            if "infra" in machine_info["role"]:
                fqdns = machine_info["fqdns"]
                return fqdns[(fqdns.find(".") + 1):]
    return None


def build_k8s_config(config_path):
    cluster_path = os.path.join(config_path, "cluster.yaml")
    if not os.path.isfile(cluster_path):
        cluster_path = os.path.join(config_path, "status.yaml")

    with open(cluster_path) as f:
        cluster_config = yaml.full_load(f)

    config = Configuration()

    infra_host = find_infra_node_name(cluster_config["machines"])

    if "cluster.yaml" in cluster_path:
        config.host = "https://%s.%s:1443" % (
            infra_host, cluster_config["network"]["domain"])
        basic_auth = cluster_config["basic_auth"]
    else:
        config.host = cluster_config["machines"][infra_host]["fqdns"]
        with open(os.path.join(config_path, "clusterID",
                               "k8s_basic_auth.yml")) as auf:
            basic_auth = yaml.safe_load(auf)["basic_auth"]

    config.username = basic_auth.split(",")[1]
    config.password = basic_auth.split(",")[0]
    bearer = "%s:%s" % (config.username, config.password)
    encoded = base64.b64encode(bearer.encode("utf-8")).decode("utf-8")
    config.api_key["authorization"] = "Basic " + encoded

    config.ssl_ca_cert = os.path.join(config_path, "ssl/apiserver/ca.pem")
    return config


def get_k8s_nodes(config_path):
    config = build_k8s_config(config_path)
    api_client = ApiClient(configuration=config)
    k8s_core_api = k8s_client.CoreV1Api(api_client)
    resp = k8s_core_api.list_node()
    return resp.items


def get_k8s_gpu_nodes(config_path):
    nodes = get_k8s_nodes(config_path)
    gpu_nodes = []
    for node in nodes:
        if node.status is not None and node.status.capacity is not None \
                and "nvidia.com/gpu" in node.status.capacity:
            gpu_nodes.append(node)
    return gpu_nodes


def get_hostname(node):
    hostname = None
    for address in node.status.addresses:
        if address.type == 'Hostname':
            hostname = address.address
    return hostname


def get_gpu_count(config_path):
    expected = get_expected_capacity(config_path)
    assert expected is not None, "expected capacity cannot be None"
    nodes = get_k8s_gpu_nodes(config_path)
    miscount_nodes = []
    for node in nodes:
        hostname = get_hostname(node)
        capacity = int(node.status.capacity["nvidia.com/gpu"])
        allocatable = int(node.status.allocatable["nvidia.com/gpu"])
        if expected != capacity or capacity != allocatable:
            logger.info("%s. expected %s, capacity %s, allocatable %s", 
                        hostname, expected, capacity, allocatable)
            miscount_nodes.append(hostname)
    if len(miscount_nodes) > 0:
        logger.info("miscount nodes: %s", ",".join(miscount_nodes))
    else:
        logger.info("no miscount nodes")


def get_ready(node):
    ready = False
    if node.status is not None and node.status.conditions is not None:
        for condition in node.status.conditions:
            if condition.type == "Ready" and condition.status == "True":
                ready = True
                break
    return ready


def get_unschedulable(config_path):
    nodes = get_k8s_gpu_nodes(config_path)
    unschedulable_nodes = []
    for node in nodes:
        hostname = get_hostname(node)
        unschedulable = node.spec.unschedulable is True
        ready = get_ready(node)
        if unschedulable is True or ready is not True:
            logger.info("%s. unschedulable %s, ready %s",
                        hostname, unschedulable, ready)
            unschedulable_nodes.append(hostname)
    if len(unschedulable_nodes) > 0:
        logger.info("unschedulable nodes: %s", ",".join(unschedulable_nodes))
    else:
        logger.info("no unschedulable nodes")


def ssh_exec(params):
    identity_file, user, host, command = params
    ssh_command = \
        """ssh -q -o "StrictHostKeyChecking no" -o "UserKnownHostsFile=/dev/null" -i %s "%s@%s" "%s" """ % \
        (identity_file, user, host, command)
    output = subprocess.check_output(ssh_command, shell=True)
    return output.decode()


def parallel_ssh(config_path, nodes, command):
    identity_file = os.path.join(config_path, "sshkey", "id_rsa")
    user = get_user(config_path)
    domain = get_domain(config_path)
    arg_lists = []
    for node in nodes:
        host = "%s.%s" % (node, domain)
        arg_lists.append((identity_file, user, host, command))

    with multiprocessing.Pool(len(nodes)) as pool:
        results = pool.map(ssh_exec, arg_lists)
    return results


def ssh_exec_hostname(config_path, nodes):
    cmd = "hostname"
    results = parallel_ssh(config_path, nodes, cmd)
    for i, node in enumerate(nodes):
        logger.info("[%s] %s", node, results[i])


def get_ib(config_path):
    cmd = "ibstatus; ifconfig ib0"
    nodes = get_k8s_gpu_nodes(config_path)
    results = parallel_ssh(config_path, nodes, cmd)
    bad_ib_nodes = []
    for i, node in enumerate(nodes):
        if "4: ACTIVE" in results[i] and "mtu 2044" in results[i]:
            continue
        logger.info("[%s] %s", node, results[i])
        bad_ib_nodes.append(node)
    if len(bad_ib_nodes) > 0:
        logger.info("bad ib nodes: %s", ",".join(bad_ib_nodes))
    else:
        logger.info("no bad ib nodes")


def restart_kubelet(config_path, nodes):
    cmd = "sudo systemctl restart kubelet"
    _ = parallel_ssh(config_path, nodes, cmd)


def restart_walinuxagent(config_path, nodes):
    cmd = "sudo systemctl restart walinuxagent"
    _ = parallel_ssh(config_path, nodes, cmd)


def main(args):
    config = args.config
    action = args.action
    nodes = args.nodes
    if nodes is not None:
        nodes = nodes.split(",")

    if action == "gpu-count":
        get_gpu_count(config)
    elif action == "unschedulable":
        get_unschedulable(config)
    elif action == "ib":
        get_ib(config)
    elif action == "hostname":
        assert nodes is not None
        ssh_exec_hostname(config, nodes)
    elif action == "kubelet":
        assert nodes is not None
        restart_kubelet(config, nodes)
    elif action == "walinuxagent":
        assert nodes is not None
        restart_walinuxagent(config, nodes)
    else:
        logger.exception("Unrecognized action")


if __name__ == '__main__':
    logging.basicConfig(
        format=
        "%(asctime)s: %(levelname)s - %(filename)s:%(lineno)d@%(process)d: %(message)s",
        level=logging.INFO)
    parser = argparse.ArgumentParser()
    parser.add_argument("--config",
                        "-c",
                        required=True,
                        help="path to config dir")
    parser.add_argument("--action",
                        "-a",
                        required=True,
                        help="action to take")
    parser.add_argument("--nodes",
                        "-n",
                        required=False,
                        default=None,
                        help="comma separated list of nodes")
    args = parser.parse_args()

    main(args)
